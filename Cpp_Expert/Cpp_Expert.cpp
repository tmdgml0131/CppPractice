#include <bits/stdc++.h>
// 현재 페이지 : 476
using namespace std;

#pragma region Chapter 00.템플릿

#pragma endregion

#pragma region 1.0 템플릿
/*



*/
#pragma endregion

//-------------------------------------------------------------------------------------------------//
#pragma region Chapter 01
    #pragma region 1.1 C++에서 빌드는 어떻게 이루어지는가
    /*
    # 개요
    C++에서 작성한 소스코드를 실행 가능한 실행 파일로 변환하기 위해서는, 일련의 4단계를 따른다.
    1. 먼저 #include / #define 같은 전처리기 매크로들을 처리하는 **전처리( Preprocessing ) 단계**
    2. 각각의 소스 파일을 어셈블리 명령어로 변환하는 **컴파일( Compile ) 단계**
    3. 어셈블리 코드들을 실제 기계어로 이루어진 목적 코드( Object File ) 로 변환하는 **어셈블( Assemble ) 단계**
    4. 마지막으로 각각의 목적 코드들을 한데 모아서 하나의 실행 파일로 만들어주는 **링킹( Linking )단계로 나누어 진다.

    대부분 전처리 단계 - 컴파일 단계 - 어셈블 단계를 모두 합쳐 컴파일 단계 하나로 생각해도 무방하다.
    즉, 많은 경우 어셈블 명령어 같은 파일을 생성하지 않고 바로 목적 코드로 넘어간다고 생각해도 무방하다.

    # 전처리 단계
    전처리 단계와 컴파일 단계는 모두 컴파일러 안에서 수행됩니다.
    C++ 표준에 따르면, 이 두 단계는 총 8단계의 세부 단계로 나뉜다.
    1~6단계 까지를 전처리, 나머지 과정을 컴파일 과정으로 볼 수 있다.

    ## 1단계 : 문자들 해석
    첫 번째 단계는 소스 파일에 있는 문자들의 해석입니다.
    기본적으로 C++ 코드에서는 총 96개의 문자들로 이루어진 **Basic Source Character Set**이 있는데,

        * 5 종류의 공백 문자들 ( 스페이스, 탭, 개행 문자 등 )
        * 10 종류의 숫자들 ( 0부터 9까지 )
        * 52 종류의 알파벳 대소문자
        * 29 종류의 특수 문자들 ( $, %, # 등 )
    
    으로 구성되어 있습니다. 이 Set에 해당되지 않는 다른 모든 문자들은 \u를 통해
    유니코드 값으로 치환되거나, 컴파일러에 의해서 따로 해석됩니다.

    ## 2단계 : \ 문자 해석하기
    만약에 백슬래시 ( \ ) 문자가 문장 맨 끝 부분에 위치해있다면, 
    해당 문장과 바로 다음에 오는 문장이 하나로 합쳐지고 개행 문자는 삭제 됩니다.

    ```cpp
    abc def

    // ------ //

    abcdef
    ```

    ## 3단계 : 전처리 토큰들로 분리하기
    소스 파일을 주석 ( Comment ), 공백 문자, **전처리 토큰 ( Preprocessing token )** 들로 분리하는 단계입니다.
    **전처리 토큰**은 C++에서 가장 기본적인 문법 요소로, 후에 컴파일러가 사용하는 **컴파일러 토큰**의 근간이 됩니다.
    아래 해당 하는 것들이 전처리 토큰에 포함됩니다.

        * 헤더이름 ( <iostream>과 같이 )
        * 식별자
        * 문자/문자열 리터럴
        * 연산자를 ( +, ## )
         
    이 단계에서 raw string literal을 확인하여, 만일 1~2단계를 거치며 해당 문자열 안의 내용이 바뀌었다면 그 변경은 취소됩니다.

    또한 주석은 모두 공백 문자 하나로 변경됩니다.

    참고로 컴파일러가 전처리기 토큰을 인식할 때에는 가능한 긴 전처리 토큰을 만드려고 합니다.
    이러한 규칙을 **Maxiamal Munch**라고 부릅니다. 예를 들어
    ```cpp
    int a = bar+++++baz;
    ```
    라는 문장이 있을 때, 우리는 
    ```cpp
    bar++ + ++baz
    ```
    를 의도한 것이겠지만, Maximal Munch 규칙에 따라 컴파일러는 
    ```cpp
    bar++ ++ +baz
    ```
    로 해석되어 컴파일 오류가 발생합니다.

    마찬가지로
    ```cpp
    int bar = 0xE+foo;
    ```
    역시 우리는
    ```cpp
    0xE + foo
    ```
    를 의도한 것이겠지만, 컴파일러의 경우
    ```cpp
    0xE+ foo
    ```
    로 해석하여 오류가 발생합니다. 그 이유는, 부동 소수점 리터럴의 경우


    */
    #pragma endregion

#pragma endregion


#pragma region 질문 리스트
/*
1장 : 
    1. C++ 에서 빌드는 어떻게 이루어지는가?
    2. 런타임, 컴파일 타임?
    3. 스택과 힙
    4. 스마트 포인터
    5. 참조 전달 방식
    6. const 참조 전달 방식
    7. 예외 처리
    8. 타입 추론 auto
    9. decltype
    10. 생성자 이니셜라이저
    11. 유니폼 초기화
    12. 컴파일 에러 / 런타임 에러 / 링킹 에러 / 논리 에러 / 파스 에러

2장 :
    1. 스트링 리터럴
    2. 로 스트링 리터럴
    3. 메모리 영역(코드, 데이터, 스택, 힙)
    4. string_view

3장 :
    1. 주석 작성법

4장 :
    1. 추상화
    2. 재사용
    3. 빅-오 표기법

5장 :
    1. has-a 관계, is-a 관계
    2. 다형성과 코드 재사용
    3. 상속
    4. 믹스인 클래스
    5. 인터페이스

6장 :
    1. 응집도 / 결합도
    2. 템플릿
    3. 개방/폐쇄 원칙, 그리고 상속
    4. SOLID 원칙

7장 :
    1. 메모리 할당 / 스택과 힙
    2. 메모리 누수
    3. malloc() 과 new 그리고 realloc()
    4. 힙 영역의 배열 할당
    5. 포인터의 타입캐스팅
    6. 포인터 연산
    7. 가비지 컬렉션
    8. unique_ptr
    9. shared_ptr
    10. 레퍼런스 카운팅
    11. weak_ptr
    12. 메모리 문제
    13. 댕글링 포인터

8장 :
    1. struct와 class 그리고 접근 제한자
    2. this 포인터
    3. 객체의 라이프 사이클
    4. 생성자 / 디폴트 생성자 / 생성자 이니셜라이저 순서 주의사항 / 복제 생성자
    5. 생성자 정리
    6. 레퍼런스 전달
    7. 소멸자
    8. 대입연산자

9장 :
    1. friend
    2. 얕은 복제, 깊은 복제
    3. 복제 후 맞바꾸기 패턴
    4. Lvalue, Rvalue
    5. Rvalue Reference
    6. 이동 의미론 ( Move Semantics )
    7. 표준 라이브러리 std::swap
    8. Rule of Three, Rule of Five, Rule of Zero
    9. Static 메서드
    10. const 메서드
    11. mutable 변수
    12. 오버로딩
    13. const 기반 오버로딩
    14. 명시적으로 오버로딩 제거하기
    15. 인라인 메서드
    16. 데이터 멤버의 종류
    17. const static 멤버 변수
    18. 클래스에 열거 타입 정리
    19. 연산자 오버로딩 / 전역 연산자 오버로딩

10장 :
    1. 상속
    2. final 키워드 ( 클래스 / 메서드 )
    3. 오버라이딩 / Virtual / override 키워드
    4. 슬라이싱
    5. 정적 바인딩 / 동적 바인딩
    6. virtual 소멸자
    7. Cpp의 객체 생성과정
    8. 업캐스팅 / 다운캐스팅
    9. 순수 가상 함수
    10. 다중 상속
    11. 리스코프 치환 원칙
    12. 클래스 내에서의 using 키워드
    13. 생성자의 명시적 상속
    14. RTTI
    15. non-public 클래스 상속 
    16. 가상 베이스 클래스

*/
#pragma endregion




//-------------------------------------------------------------------------------------------------//

int main()
{
    std::cout << "Hello World!\n";
    
}

