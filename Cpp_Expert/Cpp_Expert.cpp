#include <bits/stdc++.h>
// 현재 페이지 : 476
using namespace std;

#pragma region Chapter 00.템플릿

#pragma endregion

#pragma region 1.0 템플릿
/*



*/
#pragma endregion

//-------------------------------------------------------------------------------------------------//
#pragma region Chapter 01
    #pragma region 1.1 C++에서 빌드는 어떻게 이루어지는가
    /*
    # 개요
    C++에서 작성한 소스코드를 실행 가능한 실행 파일로 변환하기 위해서는, 일련의 4단계를 따른다.
    1. 먼저 #include / #define 같은 전처리기 매크로들을 처리하는 **전처리( Preprocessing ) 단계**
    2. 각각의 소스 파일을 어셈블리 명령어로 변환하는 **컴파일( Compile ) 단계**
    3. 어셈블리 코드들을 실제 기계어로 이루어진 목적 코드( Object File ) 로 변환하는 **어셈블( Assemble ) 단계**
    4. 마지막으로 각각의 목적 코드들을 한데 모아서 하나의 실행 파일로 만들어주는 **링킹( Linking )단계로 나누어 진다.

    대부분 전처리 단계 - 컴파일 단계 - 어셈블 단계를 모두 합쳐 컴파일 단계 하나로 생각해도 무방하다.
    즉, 많은 경우 어셈블 명령어 같은 파일을 생성하지 않고 바로 목적 코드로 넘어간다고 생각해도 무방하다.

    # 전처리 단계
    전처리 단계와 컴파일 단계는 모두 컴파일러 안에서 수행됩니다.
    C++ 표준에 따르면, 이 두 단계는 총 8단계의 세부 단계로 나뉜다.
    1~6단계 까지를 전처리, 나머지 과정을 컴파일 과정으로 볼 수 있다.

    ## 1단계 : 문자들 해석
    첫 번째 단계는 소스 파일에 있는 문자들의 해석입니다.
    기본적으로 C++ 코드에서는 총 96개의 문자들로 이루어진 **Basic Source Character Set**이 있는데,

        * 5 종류의 공백 문자들 ( 스페이스, 탭, 개행 문자 등 )
        * 10 종류의 숫자들 ( 0부터 9까지 )
        * 52 종류의 알파벳 대소문자
        * 29 종류의 특수 문자들 ( $, %, # 등 )
    
    으로 구성되어 있습니다. 이 Set에 해당되지 않는 다른 모든 문자들은 \u를 통해
    유니코드 값으로 치환되거나, 컴파일러에 의해서 따로 해석됩니다.

    ## 2단계 : \ 문자 해석하기
    만약에 백슬래시 ( \ ) 문자가 문장 맨 끝 부분에 위치해있다면, 
    해당 문장과 바로 다음에 오는 문장이 하나로 합쳐지고 개행 문자는 삭제 됩니다.

    ```cpp
    abc def

    // ------ //

    abcdef
    ```

    ## 3단계 : 전처리 토큰들로 분리하기
    소스 파일을 주석 ( Comment ), 공백 문자, **전처리 토큰 ( Preprocessing token )** 들로 분리하는 단계입니다.
    **전처리 토큰**은 C++에서 가장 기본적인 문법 요소로, 후에 컴파일러가 사용하는 **컴파일러 토큰**의 근간이 됩니다.
    아래 해당 하는 것들이 전처리 토큰에 포함됩니다.

        * 헤더이름 ( <iostream>과 같이 )
        * 식별자
        * 문자/문자열 리터럴
        * 연산자를 ( +, ## )
         
    이 단계에서 raw string literal을 확인하여, 만일 1~2단계를 거치며 해당 문자열 안의 내용이 바뀌었다면 그 변경은 취소됩니다.

    또한 주석은 모두 공백 문자 하나로 변경됩니다.

    참고로 컴파일러가 전처리기 토큰을 인식할 때에는 가능한 긴 전처리 토큰을 만드려고 합니다.
    이러한 규칙을 **Maxiamal Munch**라고 부릅니다. 예를 들어
    ```cpp
    int a = bar+++++baz;
    ```
    라는 문장이 있을 때, 우리는 
    ```cpp
    bar++ + ++baz
    ```
    를 의도한 것이겠지만, Maximal Munch 규칙에 따라 컴파일러는 
    ```cpp
    bar++ ++ +baz
    ```
    로 해석되어 컴파일 오류가 발생합니다.

    마찬가지로
    ```cpp
    int bar = 0xE+foo;
    ```
    역시 우리는
    ```cpp
    0xE + foo
    ```
    를 의도한 것이겠지만, 컴파일러의 경우
    ```cpp
    0xE+ foo
    ```
    로 해석하여 오류가 발생합니다. 그 이유는, 부동 소수점 리터럴의 경우 E를 통해서 지수를
    지정할 수 있기 때문입니다. (0xE+10 등..)

    ## 4단계 : 전처리기 실행 단계
    전처리 토큰들로 분리하였으므로, 전처리기를 실행합니다.

        * #include에 지정된 파일의 내용을 복사
        * #define에 정의된 매크로를 사용해서 코드를 치환
        * #if, #ifndef와 같은 구문을 실행해서 코드를 치환
        * #pragma와 같은 컴파일러 명령문들을 해석
    
    또한, 보통 헤더파일이 여러번 중복되어 include 되더라도
    한 번만 포함이 되게 아래와 같은 헤더 가드(Header guard)를 작성합니다.

    ```cpp
    #ifndef A_H
    #define A_H

    class A{};
    #endif
    ```
    위와 같은 헤더 가드가 작동하는 이유는 예를 들어서
    ```cpp
    #include "a.h"
    #include "a.h"

    int main{}
    ```
    을 하더라도, 전처리기에 의해서
    ```cpp
    #ifndef A_H
    #define A_H
    
    class A {};
    #endif
    #ifndef A_H
    #define A_H
    
    class A {};
    #endif
    int main() {}
    ```
    와 같이 변경되지만, 두 번째 ifndef에서는 이미 A_H가 정의되어 있기 때문에,
    #ifndef와 #endif 사이의 모든 내용들이 개행 문자로 치환됩니다. 따라서,
    ```cpp
    class A {};
    int main() {}
    ```
    로 바뀌게 됩니다.

    ### 참고
    간단히 생각해봐도 매우 비효율적입니다. #include<iostream>을 포함하는 간단한 main 함수라도
    실제 컴파일러가 보는 코드의 길이는 2만 7천줄이기 때문입니다.
    이와 같은 문제 해결을 위해, 미리 컴파일된 헤더(Precompiled header)라는 개념이 있지만, 사용시에 제약이 있습니다.

    C++20에서는 모듈(module)이라는 개념을 도입해서 이와 같은 문제의 해결이 가능합니다.
    하지만 2020년을 기준으로 모듈이 정식적으로 컴파일러에 구현된 것은 아니기 때문에,
    이를 사용하려면 시간이 필요할 것입니다.


    ## 5단계 : 실행문자 셋으로 변경하기
    모든 문자들은 이전의 소스 코드 문자 셋에서 **실행 문자 셋( Execution character set )**의 문자들로 변경됩니다.
    마찬가지로 이전의 Escaped된 문자들도 실행 문자 셋의 문자들로 변경 됩니다.

    ## 6단계 : 인접한 문자열 합치기
    이 단계에선 인접한 문자열들이 하나로 합쳐집니다.
    ```cpp
    std::cout << "abc"
                 "def";
    ```
    의 경우
    ```cpp
    std::cout<< "abcdef";
    ```
    로 변경됩니다.

    여기까지가 **전처리기 과정** 이라 생각하면 됩니다.
    ***
    # 컴파일
    전처리기 과정이 끝나고 나면 실제 컴파일 과정이 수행됩니다.
    컴파일 과정에서는 앞서 생성되었던 전처리기 토큰들을 바탕으로 실제 컴파일 토큰을 생성하여 분석합니다.
    
    ## 7단계 : 해석 유닛 생성( Translation Unit )
    이 단계에서 우리가 소위 말하는 **컴파일**이 이루어집니다.
    전처리기 토큰들이 컴파일 토큰으로 변환이 되고, 컴파일 토큰들은 컴파일러에 의해 해석되어
    해석 유닛( Translation Unit - 줄여서 보통 TU )을 생성하게 됩니다.
    참고로 이 해석 유닛은 각 소스파일 별로 하나씩 존재하게 됩니다.

    ## 8단계 : 인스턴스 유닛 생성( instantiation Unit )
    컴파일러는 생성된 TU를 분석하여 필요로 하는 템플릿 인스턴스들을 확인합니다.
    템플릿들의 정의 위치가 확인이 되면 해당 템플릿들의 인스턴스화가 진행되고 이를 통해 인스턴스 유닛이 생성됩니다.
    
    이 단계를 마치게 되면 컴파일러는 비로소 목적 코드를 생성할 수 있게됩니다.
    ***
    # 링킹( Linking )
    마지막으로 링킹 단계에서는 컴파일러가 생성한 목적 파일들과
    외부 라이브러리 파일들을 모아서 실행 파일을 생성합니다.

    이 링킹 과정이 끝나면, 사용하는 시스템에 따라서 각기 다른 형태의 파일들을 생성하게 됩니다.
    윈도우즈 계열에서 주로 사행하는 실행 파일 형태는 Portable Executable 이라 불리는
    PE 파일 형식의 파일을 생성하고 ( .exe ), 리눅스 계열의 시스템의 경우 Executable and Linkable Format, 흔히 ELF라 불리는 형태의 실행 파일을 생성합니다.

    다음 강의에서는 링킹( Linking )에 대해서 다루겠습니다.
    ***
    참조 : 모두의 코드 : 씹어먹는 C++
    ***

    */
    #pragma endregion
    #pragma region 1.2 컴파일
    /*
    # 개요
    앞선 포스트에서 빌드의 7번째 단계 후, 각 코드 별로 해석 유닛( TU )를 생성한다고 했습니다.
    물론, 이 TU가 생성이 되기 위해선, 흔히 생각하는 C++상에서의 문법 오류가 없어야 합니다.
    하지만 우리가 잘 인지하지 못하는 TU에 적용되는 중요한 규칙이 있습니다.
    바로 **각 TU에 존재하는 모든 변수, 함수, 클래스, enum, 템플릿 등등의 정의( Definition )은 유일**해야하고,
    **inline이 아닌 모든 함수의 변수들의 정의는 전체 프로그램에서 유일해야 한다.**라는
    **유일 정의 규칙( One Definition Rule - ODR )** 입니다.
    그럼 C++에서 이야기 하는 **정의** 란 무엇일까요?
    ***
    # 정의( Definition )와 선언( Declaration )
    우리는 종종 정의와 선언을 혼동해서 사용하곤 합니다.
    하지만 C++에서 이 둘은 엄연히 다른 개념입니다.
    먼저 **선언( Declaration )**이란 TU에 새로운 이름을 도입하거나,
    기존에 선언된 이름을 재선언 하는 것입니다.

    예를 들어
    ```cpp
    int f();
    ```
    의 경우, `f 라는 함수를 **선언**했습니다.

    그리고 정의는 선언을 포함하는 개념으로, **선언된 개체를 완전히 정의함**을 뜻합니다. 예를 들어,
    ```cpp
    int a;
    ```
    의 경우 `a 라는 `int 변수를 **정의**한 것입니다.
    하지만 `extern 지정자가 들어간 선언의 경우 명시적으로 초기화 되지 않는다면 선언입니다.
    ```cpp
    extern const int a;             // a를 선언하였지만 정의하지 않음
    extern const int b = 1;         // b를 정의함
    ```
    위의 경우는, a는 선언, b는 정의 입니다.
    
    또한, 클래스 정의 내부에 `inline이 아닌 `static 멤버의 경우 정의입니다.
    ```cpp
    struct S {
        int n ;                         // S::n 정의
        static int i;                   // S::i를 선언하지만 정의는 아님
        inline static int x;            // S::x 를 정의
    };                                  // S를 정의
    int S::i;                           // S::i를 정의
    ```

    # 유일 정의 규칙( One Definition Rule )
    > 각 TU에 존재하는 모든 변수, 함수, 클래스, enum, 템플릿 등등의 정의( Definition )은
    > 유일해야 하고, `inline 이 아닌 모든 함수의 변수들의 정의는 전체 프로그램에서 유일해야 한다.

    이 말은 즉, TU안에 같은 **선언**은 여러개 있어도 괜찮다는 의미 입니다. 실제로
    ```cpp
    int f();        // f 의 선언
    int f();        // f 의 선언
    int f();        // f 의 선언
    ```
    위 코드는 문제가 없습니다. 왜냐하면, `int f() 는 `f 의 선언이지 정의가 아니기 때문입니다. 하지만
    ```cpp
    int f() 
    {
        return 0;
    }
    int f() 
    {
        return 0;
    }
    ```
    위와 같은 경우 컴파일을 하였다면, 다음과 같은 오류가 발생하게 됩니다.
    ```cpp
    test.cc:5:5: error: redefinition of ‘int f()’
    5 | int f() {
      |     ^
    test.cc:1:5: note: ‘int f()’ previously defined here
    1 | int f() {
      |     ^
    ```

    또 ODR이 내포하는 다른 뜻은, **inline이 아닌 모든 함수의 변수들의 정의는 전체 프로그램에서 유일**해야한다.
    즉, `inline 으로 정의되지 않는 모든 함수들과 변수들의 경우 프로그램을 구성하는 모든 TU에 정의가 단 하나 있어야합니다.

    # inline 키워드의 의미
    원래 `inline 키워드가 처음 도입되었을 때의 의미는, 컴파일러에게
    **이 함수를 호출하는 문장을 그냥 이 함수의 내용으로 치환시켜도 된다** 라는 의미였습니다.
    
    하지만 현대의 C++컴파일러는 굉장히 똑똑해졌기 때문에, 우리가 굳이 `inline이라고 명시하지 않아도
    만일 인라인하는 것이 효율이 좋다면 인라인을 시키고, 
    반대로 인라인 함수가 인라인을 안했을 때, 효율이 좋다면 인라인화를 하지 않습니다.
    따라서 현대의 `inline 키워드는 다음과 같은 의미를 나타낸다고 보시는게 낫습니다.
    > 이 함수는 여러개의 TU에 정의되어 있어도 괜찮음!!
    */
    #pragma endregion
    #pragma region 1.3 링킹
    /*
    # 개요
    링킹 과정에서는 목적 코드들에 정의된 심볼들( 함수들이나 객체들 ) 의 위치를 확정 시킵니다.

    이때, C++에서 심볼들의 위치를 정할 때, 어떠한 방식으로 정할지 알려주는 키워드들이 있는데,
    이들을 바로 `Storage Class Specifier` 라고 합니다. 굳이 번역하자면 `저장 방식 지정자` 정도 입니다.

    # 저장 방식 지정자( Storage Class Specifier )
    C++에서 허용하는 저장 방식 지정자는 아래와 같이 총 4가지 입니다.

        * `static`
        * `thread_local`
        * `extern`
        * `mutable` <- 이 녀석의 경우 저장 기간과 링크 방식에 영향을 주지는 않습니다.
    
    이전에는 `auto`와 `register` 지정자들도 있었지만, 각각 C++11 과 C++17에서 사라졌습니다.
    
    이 키워드들을 통해 심볼들의 두 가지 중요한 정보들을 지정할 수 있습니다.
    바로 `저장 기간( Storage Duration )`과 `링크 방식( Linkage )` 입니다.

    # 저장 기간( Storage Duration )
    프로그램에서의 모든 객체들의 경우 반드시 아래 넷




    */
    #pragma endregion



#pragma endregion


#pragma region 질문 리스트
/*
1장 : 
    1. C++ 에서 빌드는 어떻게 이루어지는가?
    1.1 컴파일
    1.2 링킹
    2. 런타임, 컴파일 타임?
    3. 스택과 힙
    4. 스마트 포인터
    5. 참조 전달 방식
    6. const 참조 전달 방식
    7. 예외 처리
    8. 타입 추론 auto
    9. decltype
    10. 생성자 이니셜라이저
    11. 유니폼 초기화
    12. 컴파일 에러 / 런타임 에러 / 링킹 에러 / 논리 에러 / 파스 에러

2장 :
    1. 스트링 리터럴
    2. 로 스트링 리터럴
    3. 메모리 영역(코드, 데이터, 스택, 힙)
    4. string_view

3장 :
    1. 주석 작성법

4장 :
    1. 추상화
    2. 재사용
    3. 빅-오 표기법

5장 :
    1. has-a 관계, is-a 관계
    2. 다형성과 코드 재사용
    3. 상속
    4. 믹스인 클래스
    5. 인터페이스

6장 :
    1. 응집도 / 결합도
    2. 템플릿
    3. 개방/폐쇄 원칙, 그리고 상속
    4. SOLID 원칙

7장 :
    1. 메모리 할당 / 스택과 힙
    2. 메모리 누수
    3. malloc() 과 new 그리고 realloc()
    4. 힙 영역의 배열 할당
    5. 포인터의 타입캐스팅
    6. 포인터 연산
    7. 가비지 컬렉션
    8. unique_ptr
    9. shared_ptr
    10. 레퍼런스 카운팅
    11. weak_ptr
    12. 메모리 문제
    13. 댕글링 포인터

8장 :
    1. struct와 class 그리고 접근 제한자
    2. this 포인터
    3. 객체의 라이프 사이클
    4. 생성자 / 디폴트 생성자 / 생성자 이니셜라이저 순서 주의사항 / 복제 생성자
    5. 생성자 정리
    6. 레퍼런스 전달
    7. 소멸자
    8. 대입연산자

9장 :
    1. friend
    2. 얕은 복제, 깊은 복제
    3. 복제 후 맞바꾸기 패턴
    4. Lvalue, Rvalue
    5. Rvalue Reference
    6. 이동 의미론 ( Move Semantics )
    7. 표준 라이브러리 std::swap
    8. Rule of Three, Rule of Five, Rule of Zero
    9. Static 메서드
    10. const 메서드
    11. mutable 변수
    12. 오버로딩
    13. const 기반 오버로딩
    14. 명시적으로 오버로딩 제거하기
    15. 인라인 메서드
    16. 데이터 멤버의 종류
    17. const static 멤버 변수
    18. 클래스에 열거 타입 정리
    19. 연산자 오버로딩 / 전역 연산자 오버로딩

10장 :
    1. 상속
    2. final 키워드 ( 클래스 / 메서드 )
    3. 오버라이딩 / Virtual / override 키워드
    4. 슬라이싱
    5. 정적 바인딩 / 동적 바인딩
    6. virtual 소멸자
    7. Cpp의 객체 생성과정
    8. 업캐스팅 / 다운캐스팅
    9. 순수 가상 함수
    10. 다중 상속
    11. 리스코프 치환 원칙
    12. 클래스 내에서의 using 키워드
    13. 생성자의 명시적 상속
    14. RTTI
    15. non-public 클래스 상속 
    16. 가상 베이스 클래스

*/
#pragma endregion




//-------------------------------------------------------------------------------------------------//

int main()
{
    std::cout << "Hello World!\n";
    
}

