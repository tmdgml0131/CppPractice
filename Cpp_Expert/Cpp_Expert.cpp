#include <bits/stdc++.h>
// 현재 페이지 : 476
using namespace std;

#pragma region Chapter 00.템플릿

#pragma endregion

#pragma region 1.0 템플릿
/*



*/
#pragma endregion

//-------------------------------------------------------------------------------------------------//
#pragma region Chapter 01
    #pragma region 1.1 C++에서 빌드는 어떻게 이루어지는가
    /*
    # 개요
    C++에서 작성한 소스코드를 실행 가능한 실행 파일로 변환하기 위해서는, 일련의 4단계를 따른다.
    1. 먼저 #include / #define 같은 전처리기 매크로들을 처리하는 **전처리( Preprocessing ) 단계**
    2. 각각의 소스 파일을 어셈블리 명령어로 변환하는 **컴파일( Compile ) 단계**
    3. 어셈블리 코드들을 실제 기계어로 이루어진 목적 코드( Object File ) 로 변환하는 **어셈블( Assemble ) 단계**
    4. 마지막으로 각각의 목적 코드들을 한데 모아서 하나의 실행 파일로 만들어주는 **링킹( Linking )단계로 나누어 진다.

    대부분 전처리 단계 - 컴파일 단계 - 어셈블 단계를 모두 합쳐 컴파일 단계 하나로 생각해도 무방하다.
    즉, 많은 경우 어셈블 명령어 같은 파일을 생성하지 않고 바로 목적 코드로 넘어간다고 생각해도 무방하다.

    # 전처리 단계
    전처리 단계와 컴파일 단계는 모두 컴파일러 안에서 수행됩니다.
    C++ 표준에 따르면, 이 두 단계는 총 8단계의 세부 단계로 나뉜다.
    1~6단계 까지를 전처리, 나머지 과정을 컴파일 과정으로 볼 수 있다.

    ## 1단계 : 문자들 해석
    첫 번째 단계는 소스 파일에 있는 문자들의 해석입니다.
    기본적으로 C++ 코드에서는 총 96개의 문자들로 이루어진 **Basic Source Character Set**이 있는데,

        * 5 종류의 공백 문자들 ( 스페이스, 탭, 개행 문자 등 )
        * 10 종류의 숫자들 ( 0부터 9까지 )
        * 52 종류의 알파벳 대소문자
        * 29 종류의 특수 문자들 ( $, %, # 등 )
    
    으로 구성되어 있습니다. 이 Set에 해당되지 않는 다른 모든 문자들은 \u를 통해
    유니코드 값으로 치환되거나, 컴파일러에 의해서 따로 해석됩니다.

    ## 2단계 : \ 문자 해석하기
    만약에 백슬래시 ( \ ) 문자가 문장 맨 끝 부분에 위치해있다면, 
    해당 문장과 바로 다음에 오는 문장이 하나로 합쳐지고 개행 문자는 삭제 됩니다.

    ```cpp
    abc def

    // ------ //

    abcdef
    ```

    ## 3단계 : 전처리 토큰들로 분리하기
    소스 파일을 주석 ( Comment ), 공백 문자, **전처리 토큰 ( Preprocessing token )** 들로 분리하는 단계입니다.
    **전처리 토큰**은 C++에서 가장 기본적인 문법 요소로, 후에 컴파일러가 사용하는 **컴파일러 토큰**의 근간이 됩니다.
    아래 해당 하는 것들이 전처리 토큰에 포함됩니다.

        * 헤더이름 ( <iostream>과 같이 )
        * 식별자
        * 문자/문자열 리터럴
        * 연산자를 ( +, ## )
         
    이 단계에서 raw string literal을 확인하여, 만일 1~2단계를 거치며 해당 문자열 안의 내용이 바뀌었다면 그 변경은 취소됩니다.

    또한 주석은 모두 공백 문자 하나로 변경됩니다.

    참고로 컴파일러가 전처리기 토큰을 인식할 때에는 가능한 긴 전처리 토큰을 만드려고 합니다.
    이러한 규칙을 **Maxiamal Munch**라고 부릅니다. 예를 들어
    ```cpp
    int a = bar+++++baz;
    ```
    라는 문장이 있을 때, 우리는 
    ```cpp
    bar++ + ++baz
    ```
    를 의도한 것이겠지만, Maximal Munch 규칙에 따라 컴파일러는 
    ```cpp
    bar++ ++ +baz
    ```
    로 해석되어 컴파일 오류가 발생합니다.

    마찬가지로
    ```cpp
    int bar = 0xE+foo;
    ```
    역시 우리는
    ```cpp
    0xE + foo
    ```
    를 의도한 것이겠지만, 컴파일러의 경우
    ```cpp
    0xE+ foo
    ```
    로 해석하여 오류가 발생합니다. 그 이유는, 부동 소수점 리터럴의 경우 E를 통해서 지수를
    지정할 수 있기 때문입니다. (0xE+10 등..)

    ## 4단계 : 전처리기 실행 단계
    전처리 토큰들로 분리하였으므로, 전처리기를 실행합니다.

        * #include에 지정된 파일의 내용을 복사
        * #define에 정의된 매크로를 사용해서 코드를 치환
        * #if, #ifndef와 같은 구문을 실행해서 코드를 치환
        * #pragma와 같은 컴파일러 명령문들을 해석
    
    또한, 보통 헤더파일이 여러번 중복되어 include 되더라도
    한 번만 포함이 되게 아래와 같은 헤더 가드(Header guard)를 작성합니다.

    ```cpp
    #ifndef A_H
    #define A_H

    class A{};
    #endif
    ```
    위와 같은 헤더 가드가 작동하는 이유는 예를 들어서
    ```cpp
    #include "a.h"
    #include "a.h"

    int main{}
    ```
    을 하더라도, 전처리기에 의해서
    ```cpp
    #ifndef A_H
    #define A_H
    
    class A {};
    #endif
    #ifndef A_H
    #define A_H
    
    class A {};
    #endif
    int main() {}
    ```
    와 같이 변경되지만, 두 번째 ifndef에서는 이미 A_H가 정의되어 있기 때문에,
    #ifndef와 #endif 사이의 모든 내용들이 개행 문자로 치환됩니다. 따라서,
    ```cpp
    class A {};
    int main() {}
    ```
    로 바뀌게 됩니다.

    ### 참고
    간단히 생각해봐도 매우 비효율적입니다. #include<iostream>을 포함하는 간단한 main 함수라도
    실제 컴파일러가 보는 코드의 길이는 2만 7천줄이기 때문입니다.
    이와 같은 문제 해결을 위해, 미리 컴파일된 헤더(Precompiled header)라는 개념이 있지만, 사용시에 제약이 있습니다.

    C++20에서는 모듈(module)이라는 개념을 도입해서 이와 같은 문제의 해결이 가능합니다.
    하지만 2020년을 기준으로 모듈이 정식적으로 컴파일러에 구현된 것은 아니기 때문에,
    이를 사용하려면 시간이 필요할 것입니다.


    ## 5단계 : 실행문자 셋으로 변경하기
    모든 문자들은 이전의 소스 코드 문자 셋에서 **실행 문자 셋( Execution character set )**의 문자들로 변경됩니다.
    마찬가지로 이전의 Escaped된 문자들도 실행 문자 셋의 문자들로 변경 됩니다.

    ## 6단계 : 인접한 문자열 합치기
    이 단계에선 인접한 문자열들이 하나로 합쳐집니다.
    ```cpp
    std::cout << "abc"
                 "def";
    ```
    의 경우
    ```cpp
    std::cout<< "abcdef";
    ```
    로 변경됩니다.

    여기까지가 **전처리기 과정** 이라 생각하면 됩니다.
    ***
    # 컴파일
    전처리기 과정이 끝나고 나면 실제 컴파일 과정이 수행됩니다.
    컴파일 과정에서는 앞서 생성되었던 전처리기 토큰들을 바탕으로 실제 컴파일 토큰을 생성하여 분석합니다.
    
    ## 7단계 : 해석 유닛 생성( Translation Unit )
    이 단계에서 우리가 소위 말하는 **컴파일**이 이루어집니다.
    전처리기 토큰들이 컴파일 토큰으로 변환이 되고, 컴파일 토큰들은 컴파일러에 의해 해석되어
    해석 유닛( Translation Unit - 줄여서 보통 TU )을 생성하게 됩니다.
    참고로 이 해석 유닛은 각 소스파일 별로 하나씩 존재하게 됩니다.

    ## 8단계 : 인스턴스 유닛 생성( instantiation Unit )
    컴파일러는 생성된 TU를 분석하여 필요로 하는 템플릿 인스턴스들을 확인합니다.
    템플릿들의 정의 위치가 확인이 되면 해당 템플릿들의 인스턴스화가 진행되고 이를 통해 인스턴스 유닛이 생성됩니다.
    
    이 단계를 마치게 되면 컴파일러는 비로소 목적 코드를 생성할 수 있게됩니다.
    ***
    # 링킹( Linking )
    마지막으로 링킹 단계에서는 컴파일러가 생성한 목적 파일들과
    외부 라이브러리 파일들을 모아서 실행 파일을 생성합니다.

    이 링킹 과정이 끝나면, 사용하는 시스템에 따라서 각기 다른 형태의 파일들을 생성하게 됩니다.
    윈도우즈 계열에서 주로 사행하는 실행 파일 형태는 Portable Executable 이라 불리는
    PE 파일 형식의 파일을 생성하고 ( .exe ), 리눅스 계열의 시스템의 경우 Executable and Linkable Format, 흔히 ELF라 불리는 형태의 실행 파일을 생성합니다.

    다음 강의에서는 링킹( Linking )에 대해서 다루겠습니다.
    ***
    참조 : 모두의 코드 : 씹어먹는 C++
    ***

    */
    #pragma endregion
    #pragma region 1.2 컴파일
    /*
    # 개요
    앞선 포스트에서 빌드의 7번째 단계 후, 각 코드 별로 해석 유닛( TU )를 생성한다고 했습니다.
    물론, 이 TU가 생성이 되기 위해선, 흔히 생각하는 C++상에서의 문법 오류가 없어야 합니다.
    하지만 우리가 잘 인지하지 못하는 TU에 적용되는 중요한 규칙이 있습니다.
    바로 **각 TU에 존재하는 모든 변수, 함수, 클래스, enum, 템플릿 등등의 정의( Definition )은 유일**해야하고,
    **inline이 아닌 모든 함수의 변수들의 정의는 전체 프로그램에서 유일해야 한다.**라는
    **유일 정의 규칙( One Definition Rule - ODR )** 입니다.
    그럼 C++에서 이야기 하는 **정의** 란 무엇일까요?
    ***
    # 정의( Definition )와 선언( Declaration )
    우리는 종종 정의와 선언을 혼동해서 사용하곤 합니다.
    하지만 C++에서 이 둘은 엄연히 다른 개념입니다.
    먼저 **선언( Declaration )**이란 TU에 새로운 이름을 도입하거나,
    기존에 선언된 이름을 재선언 하는 것입니다.

    예를 들어
    ```cpp
    int f();
    ```
    의 경우, `f 라는 함수를 **선언**했습니다.

    그리고 정의는 선언을 포함하는 개념으로, **선언된 개체를 완전히 정의함**을 뜻합니다. 예를 들어,
    ```cpp
    int a;
    ```
    의 경우 `a 라는 `int 변수를 **정의**한 것입니다.
    하지만 `extern 지정자가 들어간 선언의 경우 명시적으로 초기화 되지 않는다면 선언입니다.
    ```cpp
    extern const int a;             // a를 선언하였지만 정의하지 않음
    extern const int b = 1;         // b를 정의함
    ```
    위의 경우는, a는 선언, b는 정의 입니다.
    
    또한, 클래스 정의 내부에 `inline이 아닌 `static 멤버의 경우 정의입니다.
    ```cpp
    struct S {
        int n ;                         // S::n 정의
        static int i;                   // S::i를 선언하지만 정의는 아님
        inline static int x;            // S::x 를 정의
    };                                  // S를 정의
    int S::i;                           // S::i를 정의
    ```

    # 유일 정의 규칙( One Definition Rule )
    > 각 TU에 존재하는 모든 변수, 함수, 클래스, enum, 템플릿 등등의 정의( Definition )은
    > 유일해야 하고, `inline 이 아닌 모든 함수의 변수들의 정의는 전체 프로그램에서 유일해야 한다.

    이 말은 즉, TU안에 같은 **선언**은 여러개 있어도 괜찮다는 의미 입니다. 실제로
    ```cpp
    int f();        // f 의 선언
    int f();        // f 의 선언
    int f();        // f 의 선언
    ```
    위 코드는 문제가 없습니다. 왜냐하면, `int f() 는 `f 의 선언이지 정의가 아니기 때문입니다. 하지만
    ```cpp
    int f() 
    {
        return 0;
    }
    int f() 
    {
        return 0;
    }
    ```
    위와 같은 경우 컴파일을 하였다면, 다음과 같은 오류가 발생하게 됩니다.
    ```cpp
    test.cc:5:5: error: redefinition of ‘int f()’
    5 | int f() {
      |     ^
    test.cc:1:5: note: ‘int f()’ previously defined here
    1 | int f() {
      |     ^
    ```

    또 ODR이 내포하는 다른 뜻은, **inline이 아닌 모든 함수의 변수들의 정의는 전체 프로그램에서 유일**해야한다.
    즉, `inline 으로 정의되지 않는 모든 함수들과 변수들의 경우 프로그램을 구성하는 모든 TU에 정의가 단 하나 있어야합니다.

    # inline 키워드의 의미
    원래 `inline 키워드가 처음 도입되었을 때의 의미는, 컴파일러에게
    **이 함수를 호출하는 문장을 그냥 이 함수의 내용으로 치환시켜도 된다** 라는 의미였습니다.
    
    하지만 현대의 C++컴파일러는 굉장히 똑똑해졌기 때문에, 우리가 굳이 `inline이라고 명시하지 않아도
    만일 인라인하는 것이 효율이 좋다면 인라인을 시키고, 
    반대로 인라인 함수가 인라인을 안했을 때, 효율이 좋다면 인라인화를 하지 않습니다.
    따라서 현대의 `inline 키워드는 다음과 같은 의미를 나타낸다고 보시는게 낫습니다.
    > 이 함수는 여러개의 TU에 정의되어 있어도 괜찮음!!
    */
    #pragma endregion
    #pragma region 1.3 링킹
    /*
    # 개요
    링킹 과정에서는 목적 코드들에 정의된 심볼들( 함수들이나 객체들 ) 의 위치를 확정 시킵니다.

    이때, C++에서 심볼들의 위치를 정할 때, 어떠한 방식으로 정할지 알려주는 키워드들이 있는데,
    이들을 바로 `Storage Class Specifier` 라고 합니다. 굳이 번역하자면 `저장 방식 지정자` 정도 입니다.

    # 저장 방식 지정자( Storage Class Specifier )
    C++에서 허용하는 저장 방식 지정자는 아래와 같이 총 4가지 입니다.

        * `static`
        * `thread_local`
        * `extern`
        * `mutable` <- 이 녀석의 경우 저장 기간과 링크 방식에 영향을 주지는 않습니다.
    
    이전에는 `auto`와 `register` 지정자들도 있었지만, 각각 C++11 과 C++17에서 사라졌습니다.
    
    이 키워드들을 통해 심볼들의 두 가지 중요한 정보들을 지정할 수 있습니다.
    바로 `저장 기간( Storage Duration )`과 `링크 방식( Linkage )` 입니다.
    ***
    # 저장 기간( Storage Duration )
    프로그램에서의 모든 객체들의 경우 반드시 아래 넷 중에 한 가지 방식의 저장 기간을 가지게 됩니다.

    ## 자동( Automatic ) 저장 기간
    여기에 해당하는 객체들의 경우 보통 `{}` 안에 정의된 녀석들로 코드 블록을 빠져나가게 되면 자동으로 소멸합니다.
    `static`, `extern`, `thread_local` 로 지정된 객체들 이외의 모든 지역 객체들이
    바로 이 자동 저장 기간을 가지게 됩니다. 쉽게 말해, 우리가 흔히 생각하는 **지역 변수**들이 해당됩니다.

    ```cpp
    int func()
    {
        int a;
        SomeObject x;
        {
            std::string s;
        }

        static int not_automatic;
    }
    ```
    위 경우, `a`, `x`, `s` 모두 자동 저장 기간을 가지지만 `not_automatic` 은 아닙니다.

    ## static 저장 기간
    `static` 저장 기간에 해당하는 객체들의 경우 **프로그램이 시작할 때 할당**되고, 
    **프로그램이 끝날 때 소멸** 됩니다. 그리고 `static` 객체들은 프로그램에서 유일하게 존재합니다.
    예를 들어, 지역 변수의 경우, 여러 쓰레드에서 같은 함수를 실행한다면
    같은 지역 변수의 복사본들이 여러 군데 존재하겠지만, `static` 객체들은 이 경우에도 유일하게 존재합니다.

    보통 함수 밖에 정의된 것들이나( 즉 `namespace` 단위에서 정의된 것들 ) `static`, 혹은
    `extern`으로 정의된 객체들이 `static` 저장 기간을 가집니다.
    참고로 `static` 키워드와 **static 저장 기간**을 가진다는 것을 구분해야 합니다.
    `static` 키워드가 붙은 객체들이 `static` 저장 기간을 가지는 것은 맞지만,
    다른 방식으로 정의된 것들도 `static` 저장 기간을 가질 수 있습니다.
    
    예를 들어,
    ```cpp
        int a;              // 전역 변수 static 저장 기간
        namespace ss
        {
            int b;          // static 저장 기간
        }

        extern int a;       // static 저장 기간
        int func()
        {
            static int x;   // static 저장 기간
        }
    ```
    위와 같이 여러가지 방식으로 정의된 객체들이 `static` 저장 기간을 가지게 됩니다.

    ## 쓰레드( Thread ) 저장 기간
    쓰레드 저장 기간에 해당하는 객체들의 경우 **쓰레드가 시작할 때**할당 되고, **쓰레드가 종료될 때** 소멸됩니다.
    각 쓰레드들이 해당 객체들의 복사본을 갖게 되며, `thread_local` 로 선언된 객체들이 이 쓰레드 저장 기간을 가질 수 있습니다.

    ```cpp
    #include <iostream>
    #include <thread>
    
    thread_local int i = 0;
    
    void g() { std::cout << i; }
    
    void threadFunc(int init) {
      i = init;
      g();
    }
    
    int main() {
      std::thread t1(threadFunc, 1);
      std::thread t2(threadFunc, 2);
      std::thread t3(threadFunc, 3);
    
      t1.join();
      t2.join();
      t3.join();
    
      std::cout << i;
    }
    ```
    예를 들어 아마 몇 번 실행하다보면 1230, 2130, 3120 등과 같은 결과를 볼 수 있습니다.
    그 이유는 `thread_local`로 정의된 `i` 가 각 쓰레드에 유일하게 존재하기 때문이죠.
    마치 전역 변수인 것 처럼 정의되어 있지만, 실제로는 각 쓰레드에 하나씩 복사본이 조냊하게 되고,
    각 쓰레드 안에서 해당 `i`를 전역변수인것마냥 참조할 수 있게 됩니다.

    ## 동적( Dynamic ) 저장 기간
    동적 저장 기간의 경우 동적 할당 함수를 통해서 할당 되고 해제되는 객체들을 의미 합니다.
    대표적으로 `new`와 `delete`로 정의되는 객체들을 의미합니다.

    이러한 저장 방식은 나중에 링커에서 해당 변수나 함수들을 배치시에 **어디에** 배치할 지 중요한 정보로 사용됩니다.

    # 링크 방식( Linkage )
    앞선 저장 방식이 **객체**들에게만 해당되는 내용이였다면, 링크 방식의 경우
    C++ 모든 객체, 함수, 클래스, 템플릿, 이름 공간 등을 지칭하는 이름들에 적용되는 내용입니다.
    C++에선 아래와 같은 링크 방식들을 제공합니다. 
    이 링크 방식에 따라 이름이 어디에서 사용되는지 지정할 수 있습니다.

    ## 링크 방식 없음( No Linkage )
    블록 스코프 `{}` 안에 정의되어 있는 이름들이 이 경우에 해당합니다. (`extern` 이 아닌 이상)
    링크 방식이 지정되지 않는 개체들의 경우에는 같은 스코프 안에서만 참조할 수 있습니다.
    예를 들어,
    ```cpp
    { int a = 3; }
    a;              // 오류
    ```
    위 경우, `a`라는 변수는 `{}`안에 링크 방식이 없는 상태로 정의되어 있기 때문에,
    스코프 밖에서 `a`를 참조할 수 없게 됩니다.

    ## 내부 링크 방식( Internal Linkage )
    `static`으로 정의된 함수, 변수, 템플릿 함수, 템플릿 변수들이 내부 링크 방식에 해당됩니다.
    내부 링크 방식으로 정의된 것들의 경우 **같은 TU 안에서만 참조할 수 있습니다.**
    그 외에도 익명의 이름 공간에 정의된 함수나 변수들 모두 내부 링크 방식이 적용됩니다.
    예를 들어,
    ```cpp
    namespace
    {
        int a;      // 내부 링크 방식
    }
    static int a;   // 이와 동일한 의미
    ```

    ## 외부 링크 방식( External Linkage )
    외부 링크 방식으로 정의된 객체들은 다른 TU에서도 참조 가능합니다.
    참고로 외부 링크 방식으로 정의된 개체들에 **언어 링크 방식**을 정의할 수 있어서,
    다른 언어( C와 C++ ) 사이에서 함수를 공유하는 것이 가능해 집니다.

    앞서 링크 방식이 없는 경우나 내부 링크 방식을 개체들을 정의하는 경우를 제외하면
    나머지 모두 외부 링크 방식으로 정의됨을 알 수 있습니다.
    참고로, 블록 스코프 안에 정의된 변수를 외부 링크 방식으로 선언하고 싶다면 `extern` 키워드를 사용하면 됩니다.

    ```cpp
    extern "C" int func();              // C 및 C++에서 사용할 수 있는 함수

    // C++에서만 사용할 수 있는 함수. 기본적으로 C++의 모든 함수들에 extern "C++"
    // 이 숨어 있다고 생각하면 됩니다. 따라서 아래처럼 굳이 명시해줄 필요가 없습니다.
    extern "C++" int func2();
    int func2();                        // 위와 동일
    ```
    ***
    # 이름 맹글링( Name Mangling )
    앞서 C에서 C++의 함수를 사용하기 위해서는 `extern "C"`로 언어 링크 방식을 명시해주어야 한다 했습니다.
    그 이유는, 목적 파일 생성 시, C 컴파일러가 함수 이름을 변환하는 방식과 C++ 컴파일러가
    함수 이름을 변환하는 방식이 다르기 때문입니다.

    일단 C의 경우 함수 이름 변환 자체가 이루어 지지 않습니다. 만약에 아래와 같이 `func`이란 함수를 정의했다고 해봅시다.

    ```cpp
    int func(const char* s) {}
    ```

    이를 C 컴파일러가 컴파일 하면 변환된 이름은 그냥
    ```cpp
    $ nm a.out
    0000000000000000 T func
    ```
    `func` 임을 알 수 있습니다. 참고로 `nm`은 목적 파일에 정의되어 있는 심볼들을
    모두 출력해주는 프로그램입니다.

    반면에 똑같은 소스코드를 C++ 컴파일러로 컴파일 해봅시다.

    ```cpp
    $ nm a.out
    0000000000000000 T _Z4funcPKc
    ```
    C++에서는 위와 같이 목적 코드 생성시에 컴파일러가 함수의 이름을 바꾸는 것을 볼 수 있습니다.
    이를 `이름 맹글링( Name Mangling )` 이라합니다.

    이렇게 이름 맹글링을 하는 이유는 
    C++에서는 함수 오버로딩을 통해 같은 이름의 함수를 정의할 수 있기 때문입니다.

    이름 맹글링을 하게 되면 원래의 함수 이름에 이름 공간 정보와 함수의 인자 타입 정보들이 추가됩니다.
    따라서 같은 이름의 함수일 지라도, 이름 맹글링을 거치고 나면, 다른 이름의 함수로 바뀌기 때문에
    링킹을 성공적으로 수행할 수 있습니다.

    ```cpp
    int func(const char* s) {}
    int func(int i) {}
    int func(char c) {}
    
    namespace n {
    int func(const char* s) {}
    int func(int i) {}
    int func(char c) {}
    ```
    위와 같은 이름이 같은 모든 함수는, 이름 맹글링이 되면,
    ```cpp
    $ nm test.o
    000000000000001d T _Z4funcc
    000000000000000f T _Z4funci
    0000000000000000 T _Z4funcPKc
    000000000000004a T _ZN1n4funcEc
    000000000000003c T _ZN1n4funcEi
    000000000000002d T _ZN1n4funcEPKc
    ```
    다음과 같이 변하게 됩니다.
    참고로 컴파일러마다 이름 맹글링을 하는 방식이 조금씩 다르기 때문에, 
    A라는 컴파일러에서 생성한 목적 코드를 B 컴파일러가 링킹할 때 문제가 될 수 있습니다.

    아무튼 C에서 C++의 함수를 호출하기 위해서는 반드시 이름 맹글링이 되지 않는
    함수 심볼을 생성해야 합니다. 따라서, `extern "C"`를 통해서
    > 이 함수는 이름 맹글링을 하지 마!!
    라고 컴파일러에게 전달할 수 있습니다.

    당연히도 `extern "C"`가 붙은 함수들끼리는 오버로딩을 할 수 없습니다.
    왜냐하면 심볼 생성 시, 두 함수를 구분할 수 있는 방법이 없기 때문이죠.
    ***
    # 링킹
    위 단계에서 아무런 문제가 없었다면, 이제 비로소 진짜 링킹( Linking )을 수행할 수 있습니다.
    링킹이란, `각각의 TU들에서 목적 코드들을 한데 모아서 **하나의 실행 파일**을 만들어내는 작업`입니다.
    물론 단순히 목적 코드들을 이어 붙이는 작업만 하는 것은 아닙니다.

    링킹 과정이 끝나기 전까진 변수들과 함수, 그리고 데이터들의 위치를 확정시킬 수 없습니다.
    따라서 TU들이 생성한 목적 코드들엔, 심볼들의 저장 방식과 링크방식에 따라,
    **여기 어디에 배치했으면 좋겠다** 라는 희망 사항만 써져있을 뿐입니다.
    예를 들어,
    ```cpp
    static int a = 3;
    int b = 3;
    const int c = 3;
    static int d;
    
    int func() {}
    static int func2() {}
    ```
    위 코드는

    ```cpp
    $ nm test.o
    0000000000000004 D b
    0000000000000000 T _Z4funcv
    0000000000000000 d _ZL1a
    0000000000000000 r _ZL1c
    0000000000000000 b _ZL1d
    000000000000000b t _ZL5func2v
    ```
    `nm` 프로그램을 통해 **어떠한 방식으로 링크 시, 심볼을 배치할지**에 대한 정보를 볼 수 있습니다.
    
    먼저 가운데 알파벳을 봅시다.

    대문자 알파벳의 경우, 해당 심볼은 **외부 링크 방식**으로 선언된 심볼이란 의미입니다.
    즉, 해당 심볼은 다른 TU에서 접근할 수 있는 심볼입니다.
    소문자 알파벳의 경우, 해당 심볼은 **내부 링크 방식**으로 선언된 심볼이란 의미입니다.
    따라서 해당 심볼은 이 TU 안에서만 접근이 가능합니다.

    그 다음 알파벳 자체는 어떠한 방식으로 해당 심볼을 배치할지 알려줍니다.
    nm의 man 페이지에서 전체 알파벳들에 대한 설명을 볼 수 있지만 일부만 소개한다면,

        * `B, b` : 초기화 되지 않은 데이터 섹션( BSS 섹션 )
        * `D, d' : 초기화 된 데이터 섹션
        * `T, t' : 텍스트( 코드 ) 섹션
        * `R, r` : 읽기 전용( Read Only ) 섹션
    
    입니다.

    ## 재배치( Relocation )
    컴파일된 소스 코드들을 목적 파일( Object File )로 변환한 후,
    여러 목적 파일들을 하나의 실행 파일로 결합하는 과정에서 주소들을 조정하는 작업을 말합니다.

    이는, 컴파일 시점에서는 정확한 메모리 주소를 알 수 없기 때문에,
    프로그램이 메모리에 로드된 이후에야 실행 주소를 정확히 매핑할 수 있기 때문입니다.

    링킹 단계에서 재배치 정보는 목적 파일( Object File )에 저장되어 있으며,
    실행 파일로 링킹될 때 해당 정보가 사용됩니다. 재배치는 주로 하드웨어 아키텍처와
    운영체제에 따라 다르며, 컴파일러와 링커가 이러한 재배치를 자동으로 처리합니다.
    이렇게 함으로써 프로그래머는 
    **프로그램의 절대 주소를 다룰 필요 없이 상대 주소를 사용하여 프로그래밍을 할 수 있습니다.**
    ***
    # 링크 방식( 정적 링킹 vs 동적 링킹 )
    컴파일러가 여러 목적 파일들을 링크하는 방식은 
    `정적 링킹( Static Linking )`과 `동적 링킹( Dynamic Linking )` 으로 구분됩니다.
    정적 링킹은 `정적 라이브러리( Static Library )`를 링크하는 방식이고
    동적 링킹은 `동정적 라이브러리( Dynamic Library )`, 다른 말로
    `공유 라이브러리( Shared Library )`를 링크하는 방식입니다.
    ***
    # 정적 라이브러리
    정적 라이브러리를 설명하기 전에, 먼저 **라이브러리**의 개념을 먼저 생각해봅시다.
    라이브러리란 단순히 프로그램이 동작하기 위해 필요한 외부 목적 코드들이라고 생각하시면 됩니다.

    정적 라이브러리는 우리가 필요로 하는 라이브러리가 링킹 후에
    완성된 프로그램 안에 포함된다고 생각하면 됩니다.

    ## 정적 라이브러리 만들기
    예를 들어 `foo` 라는 함수를 제공하는 foo.cc 파일과 `bar`라는 함수를 제공하는 `bar.cc` 파일이 있다고 해봅시다.

    ```cpp
    // bar.h
    void bar();

    // bar.cc
    void bar() {}

    // foo.h
    int foo();

    // foo.cc
    #include "bar.h"
    int x = 1;

    int foo()
    {
        bar();
        x++;
        return 1;
    }
    ```
    이 파일들을 컴파일 하면 foo.o 와 bar.o라는 목적 코드가 생성이 됩니다.
    만일 이 두 함수를 제공하는 정적 라이브러리를 만들기 위해서는, 이 두 목적 파일들을 묶어주면 됩니다.

    ```cpp
    $ ar crf libfoobar.a foo.o bar.o
    ```
    라고 치면 libfoobar.a 라는 정적 라이브러리가 만들어 집니다.

    이 정적 라이브러리를 사용하는 방법은 간단합니다.

    예를 들어, main.cc라는 파일에서 `foo`함수를 사용하고 싶다면, `foo`함수가 선언된 헤더파일 하나만 필요합니다.

    ```cpp
    #include "foo.h"

    int main()
    {
        foo();
    }
    ```
    통상적인 상황이라면 `main`을 컴파일 하면서 실행파일을 생성할 때,
    foo.cc 코드와 bar.cc 코드를 같이 컴파일해서 링킹했어야 하지만,
    우리는 이미 foo.cc와 bar.cc가 이미 컴파일 되어 있는
    libfoobar.a라는 라이브러리가 있기 때문에, 굳이 다시 컴파일 할 필요가 없습니다.

    따라서 아래와 같이 실행 파일을 생성 시에
    ```cpp
    # g++ main.cc libfoobar.a -0 main
    ```
    위 처럼 링크해주기만 하면 됩니다.

    이렇게 정적 라이브러리는 **링크 타임에 바인딩** 된다고 생각하시면 됩니다.
    ***
    # 공유 라이브러리( 동적 라이브러리 )
    정적 라이브러리의 가장 큰 문제점은

    **모든 프로그램들이 같은 라이브러리를 링킹하더라도, 정적으로 링킹할 경우,**
    **프로그램 내에 동일한 라이브러리 코드를 포함해야 한다** 였습니다.
    
    그렇다면 이렇게 많은 프로그램 상에서 사용되는 라이브러리를 컴퓨터 메모리 상에 딱 하나 올려놓고,
    이를 사용하는 프로그램들이 해당 라이브러리를 **공유**하면 어떨까요? 이것이 공유 라이브러리의 시작입니다.

    하지만 각 프로세스들의 메모리는 다른 프로세스들과 독립적이고 서로 접근할 수 없는 것으로 알고 있을 것입니다.
    그런데 어떻게 서로 다른 프로그램이 같은 메모리를 공유할 수 있는 것일까요?

    (사진)

    위 처럼 각각의 프로세스에는 고유의 페이지 테이블이 있습니다.
    실제 프로세스가 보는 가상 메모리에서는 가상 메모리 단의 오른쪽과 같습니다.
    문제는 프로세스마다 코드의 크기가 다르기 때문에, 공유 라이브러리가 각 프로세스의
    가상 메모리에 놓이는 위치가 다르게 된다는 점입니다.

    하지만 이는, 프로세스마다 가상메모리를 물리메모리로 변환하는 페이지 테이블이 있기 때문에
    **실제 물리 메모리에 libc 코드를 딱 한 군데만 올려 놓고, 각 프로세스의**
    **페이지 테이블 내용을 바꿔줌으로써 마치 프로세스마다 고유의 위치에 libc 코드가 있는 것처럼 사용할 수 있습니다.**
    
    ## 동적 라이브러리 만들기
    정적 라이브러리와는 다르게 동적 라이브러리는 임의의 위치에 라이브러리가 위치할 수 있어,
    섹션의 위치를 특정할 수없습니다. 따라서 결국에는 foo.cc와 bar.cc를 다시 컴파일해야 합니다.
    이 때, 컴파일 시에 인자로 **위치와 무관한 코드( Position Independent Code - PIC )를 만들라는 의미의 `-fpic` 인자를 전달해야 합니다.

    ```cpp
    $ g++ -c -fpic foo.cc
    $ g++ -c -fpic bar.cc
    $ g++ -shared foo.o bar.o -o libfoobar.so
    ```
    를 하면, 공유 라이브러리인 `libfoobar.so` 가 잘 생성된 것을 볼 수 있습니다.
    `so` -> `Shared Object`

    이를 링크하는 방법은
    ```cpp
    $ g++ main.cc libfoobar.so -g -o main
    ```
    으로 하면 됩니다.


    (사진2)
    위 사진을 보고 `main`함수에서 공유 라이브러리 내의 `bar`를 호출한다 합시다.
    만일 `bar`가 정적으로 링크된 라이브러리 함수라면, 그냥 `bar`가 정의된 위치를 호출했을 겁니다.
    하지만 공유 라이브러리의 경우, 프로그램 어디에 위치 되었는지 알 수 없기 때문에
    해당 함수를 직접 호출하는 것은 **불가능** 합니다.

    따라서 **GOT( Global Offset Table )라는 이름의 데이터 테이블을 프로그램 내부에 만든 후,
    실제 함수들의 주소값을 이 테이블에 적어 놓습니다. 그리고 우리가 함수를 호출하게 되면
    해당 함수의 실제 위치를 이 테이블을 통해서 알아내게 됩니다.

    (사진3)
    하지만 공유 라이브러리의 함수가 두 번째로 실행될 때에는
    `GOT[1]` 안에 `bar`의 주소값이 들어 있기 때문에 그냥 바로 `bar`를 호출할 수 있게 됩니다.

    이와 같이 함수가 실행될 때, `GOT` 엔트리에 등록되는 방식을 *lazy binding*이라고 합니다.

    `lazy binding`의 장점은, `bar`이 한 번도 호출되지 않았다면 시간을 절약할 수 있습니다.

    하지만 `lazy binding`의 문제점은, 해당 함수를 첫 번째로 실행하는 시점에서 많은 시간이 소요된다는 점입니다.
    따라서, 차라리 프로그램 시작 시에 모든 동적으로 바인딩 되는 심볼들을 찾아버리는 것이 오히려 나을 수도 있습니다.
    예를 들어 포토샵의 경우, 프로그램 시작 시 실행 시간이 매우 긴데, 이게 대부분 공유 라이브러리에서
    사용되는 함수들을 찾느라 걸리는 시간입니다.

    ***
    참조 : 씹어먹는 C++
    ***


    */
    #pragma endregion
    #pragma region 1.4 런타임, 컴파일 타임?
    /*
    ***
    # 개요
    이번에는 **컴파일 타임( Compile Time )**과 **런타임( Run Time )**의 의미를 알아보고,
    각 타임에 해당되는 **Compile Error**와 **RunTime Error**도 함께 알아보도록 하겠습니다.

    # Compile Time 이란?
    이전 포스팅에도 언급 하였듯, 우리가 작성한 소스코드가 **컴파일( Compile )**이라는 과정을 통해
    *기계가 읽을 수 있는 형태로 변환되는 과정*을 **컴파일 타임**이라고 합니다.

    ## Compile Error란?
    말 그대로, compile 중 발생되는 에러를 의미합니다.
    대표적으로 **Syntax Error**가 여기에 해당 됩니다.

    **Syntax 에러**란 우리가 사용하는 *언어 문법에 맞지 않는 코딩*을 했을 경우 발생하는 에러를 의미합니다.
    
    쉬운 예시로
    ```cpp
        cout << "Hello, World!';
    ```
    와 같이 큰 따옴표로 열었으나 작은 따옴표로 닫아 주는 경우 입니다.
    
    이외에도 요즘 ide에서는 빨간줄로 오류를 표시해 주는데요, 이러한 오류들이 **Compile Error**입니다.

    # Run Time 이란?
    Compile Time 이후 *프로그램이 동작되어지는 때*를 RunTime이라고 합니다.
    흔히 말하는 exe 파일을 동작 시키는 과정입니다.

    ## RunTime Error란?
    RunTIme 에러는 실행이 되어야만 확인이 가능한 에러입니다.
    즉, compile 중에는 *감지하지 못하는 에러들*입니다. (IDE 상 빨간줄로 뜨지 않음)

    쉬운 예시로
    ```cpp
    int a = 3;
    int b = 0;
    int c = a / b;
    cout << c;
    ```
    와 같이 *문법적( Syntax )으로는 오류가 없지만* 막상 실행을 해보니 발생되는 에러입니다.
    
    */
    #pragma endregion
    #pragma region 1.5 메모리 구조
    /*
    ***
    # 개요
    프로그램의 실행을 위해선, 프로그램이 **메모리( RAM - Random Access Memory ) 위에 올라갸아 한다.
    또한 프로그램 내의 여러 변수를 저장하기 위한 메모리 공간이 필요한다.
    이 메모리는, 통상적으로 코드( Code ), 데이터( Data ), 힙( Heap ), 스택( Stack )
    네 영역으로 나뉜다.

    (사진 1 )

    # 코드
    코드 영역은, 실행할 프로그램의 코드가 저장되는 장소이다.
    텍스트 영역이라고도 하지만, 주로 코드 영역이라고 부른다.
    
    코드는 우리가 읽을 수 있는 형태가 아닌, *기계어*로 저장된다.
    또한 프로그램 실행에 필요한 코드이기 때문에, **프로그램의 실행부터 끝까지 메모리에 존재**한다.
    또한 코드 영역은 **컴파일 타임**에 결정되며 프로그램 실행 중
    코드의 변경이 있으면 안되기 때문에 **읽기만 가능**하다.

    ***
    # 데이터
    데이터 영역에는, **전역( Global )변수와, 정적( Static )변수가 저장된다.
    이 또한, 프로그램이 실행되고 끝날 때까지 메모리에 존재한다.
    코드영역과 같이 프로그램이 종료되어야 메모리가 해제된다.
    또한, 코드 영역과 다르게 **Read-Write가 가능**하다.
    ***
    # 힙
    힙 영역은, **"사용자가 `동적` 으로 할당할 수 있는 공간** 이다.
    즉, 컴파일이 아닌, **런타임**에 그 크기가 정해진다.
    
    위 그림처럼, 힙 영역은 낮은 메모리 주소에서 높은 주소 방향으로 메모리를 차지하게 된다.
    또한 **스택과 메모리 공간을 공유**하기 때문에, 힙 영역이 커지면 스택 영역이 작아지고 반대의 경우도 있다.
    이러한 두 가지 경우를 다음과 같이 부른다.

        * **스택오버플로우( Stack Overflow )** : 스택 영역 > 힙 영역 ( 스택 영역이 힙 영역을 침범 )
        * **힙오버플로우( Heap Overflow )** : 힙 영역 > 스택 영역 ( 힙 영역이 스택 영역을 침범 )
    
    또한 힙 영역에는 동적으로 할당 된**클래스 인스턴스**등이 저장된다.

    ```cpp
        class Car
        {
        public:
            string name = "";
        };

        int main()
        {
            Car stackCar; // 클래스 인스턴스  <<--- 스택에 저장

            Car* heapCar = new Car(); // 동적으로 힙에 할당된 클래스 인스턴스
            delete heapCar; // 힙에 할당된 메모리 해제
        }
    ```

        * 데이터나 프로그램의 크기를 미리 알 수 없는 경우, 스택에 저장하기에 너무 큰 경우 힙 영역에 저장 **( = 메모리 크기 제한이 없음 )**
        * 메모리 할당 / 해제 작업으로 인한 속도 저하 ( = 메모리를 직접 관리해야 함 )
        * 힙 경합 ( 두 개의 쓰레드에서 동시에 데이터에 접근 원하는 경우 경합이 발생 ) 으로 인한 속도 저하
        * 힙 손상 ( 해제 후 사용, 덮어쓰기 등 ) 으로 인한 속도 저하
    ***
    # 스택
    스택 영역은 **컴파일 타임**에 크기가 결정되는 영역이며, 주로 지역 변수나 매개변수, 반환 값 등을 저장한다.
    스택 영역에 저장되는 함수의 호출 정보를 **스택 프레임( Stack Frame )이라고 부른다.

    ```cpp
        class Car
        {
        public:
            string name = "";
        };

        int main()
        {
            int test = 7;                     <<--- 지역 변수

            Car stackCar; // 클래스 인스턴스  <<--- 스택에 저장

            Car* heapCar = new Car(); // 동적으로 힙에 할당된 클래스 인스턴스
            delete heapCar; // 힙에 할당된 메모리 해제
        }
    ```

    컴파일 타임에 결정되다 보니, 힙 영역과 달리 동적으로 할당 / 해제가 불가하며, 함수가 실행되면
    스택 영역에 올라오고, 함수가 종료되면 그 함수 내의 매개변수, 지역변수 등이 해제됩니다.
    즉 **함수의 실행 / 종료에 따라 메모리의 할당 / 해제** 또한 정해집니다.
    또한, CPU에 의해 관리되어 힙 영역에 비해 **빠른 속도**를 가진다는 것이 장점이다.

    스택 영역은 높은 메모리 주소에서 낮은 메모리 주소 방향으로 메모리를 차지하게 된다.
    또한, 힙 영역과는 달리 스택 영역은 메모리 크기에 **제한이 있어서** 이에 유념해야한다.

    또한 스택은 힙 영역보다 할당 속도가 빠르다. 왜냐하면, 스택은 이미 할당된 공간을 사용하는 것이고,
    힙은 따로 할당하여 사용해야하기 때문이다.

        * CPU가 관리하여 속도가 빠르다
        * 메모리를 직접 해제하지 않아도 된다.
        * 메모리 크기에 제한이 있다.
         
    ***
    참조 : 참신 러닝 티스토리
    ***
    */
    #pragma endregion
    #pragma region 1.6 스마트 포인터 - unique_ptr
    /*
    ***
    # 개요
    C++에서 자원은 매우 중요합니다.
    컴퓨터에서 자원( Resource )라 하면 여러 가지를 꼽을 수 있지만, 예를 들어보자면
    할당한 메모리도 자원이고 Open 한 파일 역시 하나의 자원이라 할 수 있습니다.

    당연하게도, 자원의 양은 프로그램마다 한정적이기 때문에 관리를 잘 해주어야 합니다.
    이 말은 즉, 사용이 끝난 자원은 **반드시 반환**을 해서 다른 작업 때 사용할 수 있도록 해야 합니다.
    ***
    # 자원 관리의 중요성
    C++ 이후에 나온 많은 언어들은 대부분 가비지 컬렉터( Garbage Collector - GC )라 불리는
    자원 청소기가 내장되어 있습니다. 이름에서 직관적으로 알 수 있듯 프로그램 상에서
    더 이상 쓰이지 않는 자원을 자동으로 해제해 주는 역할을 합니다.

    *하지만 C++의 경우는 다릅니다.* 한 번 획득한 자원은 직접 해제하지 않는 이상
    프로그램이 종료되기 전까지 영원히 남아있게 됩니다. ( 프로그램 종료 시 운영체제가 해제 )

    간단한 예시로,
    ```cpp
    #include <iostream>

    class A 
    {
        int* data;

    public:
        A() 
        {
            data = new int[100];
            std::cout << "자원을 획득함!" <<std::endl;
        }
        
        ~A()
        {
            std::cout << "소멸자 호출!" << std::endl;
            delete[] data;
        }
    };

    void do_something() { A* pa = new A(); }

    int main()
    {
        do_something();
    }
    ```

    이를 성공적으로 컴파일 한다면
    ```cpp
    자원을 획득함!
    ```
    으로 생성자만 호출 되고, 소멸자는 호출되지 않은 점을 확인할 수 있습니다.
    그 이유는 까먹고
    ```cpp
    delete pa;
    ```
    를 하지 않았기 때문이죠. ( *delete*는 메모리를 해제하기 직전 가리키는 객체의 소멸자를 호출합니다. )

    만약 *delete*를 *do_something()* 안에서 호출 하지 않는다면,
    생성된 객체를 가리키던 *pa*는 메모리에서 사라지게 됩니다.
    따라서, *Heap* 어딘가에 클래스 *A*의 객체가 남아있지만, 그 주소값을 가지고 있는 포인터는 메모리 상에 존재하지 않게 됩니다.

    프로그램의 크기가 커질 수록, 자원을 해제하는 위치가 애매한 경우가 많아져서 숙련된 프로그래머라도
    자원 할당 해제를 놓치기 쉽습니다. 다음과 같은 상황을 생각해 봅시다.

    ```cpp
    #include <iostream>
    
    class A 
    {
        int* data;
    
    public:
        A() 
        {
            data = new int[100];
            std::cout << "자원을 획득함!" <<std::endl;
        }
        
        ~A()
        {
            std::cout << "소멸자 호출!" << std::endl;
            delete[] data;
        }
    };
    
    void thrower()
    {
        throw 1;        // 예외를 발생 시킴
    }

    void do_something() { A* pa = new A(); }
    
    int main()
    {
        try
        {
            do_something();
        }
        catch(int i
        {
            std::cout << "예외 발생!" << std::endl;
        }
    }
    ```

    성공적으로 컴파일 했다면,
    ```cpp
    자원을 획득함!
    예외 발생!
    ```

    과 같이 나옵니다.
    *thrower()*로 발생된 예외로 인해, 밑에 있는 *delete pa*가 실행되지 않고 넘어 갔습니다.
    물론 예외 처리는 정상이지만, 이로 인한 메모리 누수는 피할 수가 없게 됩니다.

    그렇다면 이 상황을 어떻게 해결해야 할까요??
    ***
    # Resource Acquisition Is Initialization - RAII
    RAII는 **자원의 획득은 초기화** 라는 C++ 의 디자인 패턴입니다.
    이는 자원 관리를 스택에 할당한 객체를 통해 수행하는 것입니다.

    **예외가 발생해서 함수를 빠져나가더라도, 함수의 스택에 정의되어 있는 
    모든 객체들은 빠짐없이 소멸자가 호출됩니다.** 이를 **Stack Unwinding**이라 합니다.
    물론 예외가 발생하지 않더라도 함수가 종료되면 소멸자들이 호출 됩니다.

    그렇다면 생각을 바꿔 이 소멸자들 안에 다 사용한 자원을 해제하는 루틴을 넣는다면 어떨까요?

    위 코드의 `pa` 같은 경우 객체가 아니기 때문에 소멸자가 호출되지 않습니다.
    그렇다면 그 대신, `pa`를 일반적인 포인터가 아닌, 포인터 `객체`로 만들어서 소멸 시,
    자신이 가리키고 있는 데이터를 같이 `delete` 하게 하면 됩니다.
    즉, 자원(이 경우 메모리)관리를 스택의 객체를 통해 수행하게 되는 것입니다.

    이렇게 똑독하게 작동하는 포인터 객체를 **스마트 포인터(Smart Pointer)라고 합니다.
    C++11 이상부터는 기존에 문제가 있던, `auto_ptr` 대신
    `unique_ptr` 과 `shared_ptr`을 제공합니다.
    ***
    # 객체의 유일한 소유권 - unique_ptr
    사용한 메모리를 해제하지 않아서 생기는 메모리 누수 외에도 다른 문제가 있습니다.

    ```cpp
        Data* data = new Data();
        Data* data2 = data;

        // data : 사용이 끝났으니 소멸 해야지
        delete data;

        // data2 : 나도 사용 다 했으니 소멸해야지
        delete data2;
    ```
    이 경우 `data`와 `data2`가 동시에 한 객체를 가리키고 있고 `delete data`를 통해
    그 객체를 소멸 시켰습니다. 하지만, `data2`가 이미 소멸된 객체를 다시 소멸시키려 합니다.
    보통 이런 경우, 메모리 오류가 나며 프로그램이 죽게 됩니다. 이렇게 이미 소멸된 객체를
    다시 소멸시키며 발생하는 버그를 **double free** 버그라고 부릅니다.

    위와 같은 문제는, 만들어진 객체의 소유권이 명확하지 않아서 입니다.
    만약, 우리가 어떤 포인터에 객체의 유일한 소유권을 부여해서, 이 포인터 외에는
    객체를 소멸 시킬 수 없다! 라고 한다면 double free 버그는 없을 것입니다.

    C++에서는 이렇게, 특정 객체에 유일한 소유권을 부여하는 포인터 객체를 `unique_ptr`이라고 합니다.

    ```cpp
        #include <iostream>
        #include <memory>
        
        class A 
        {
            int *data;
        
        public:
            A() 
            {
                std::cout << "자원을 획득함!" << std::endl;
                data = new int[100];
            }
        
          void some() 
          { 
            std::cout << "일반 포인터와 동일하게 사용가능!" << std::endl; 
          }
        
          ~A() 
          {
            std::cout << "자원을 해제함!" << std::endl;
            delete[] data;
          }
        };
        
        void do_something() 
        {
          std::unique_ptr<A> pa(new A());
          pa->some();
        }

        int main() 
        {
            do_something(); 
        }
    ```

    위 코드에서 `pa`는 스택에 정의된 객체이기 때문에, `do_something()` 함수가 종료될 때,
    자동으로 소멸자가 호출됩니다. 그리고 이 `unique_ptr`은 소멸자 안에서 자신이 가리키고 있는 자원을
    해제해 주기 때문에, 자원이 잘 해제될 수 있었습니다.

    만약에 `unique_ptr`을 복사하려고 한다면 어떨까요?

    ```cpp
        void do_something() 
    {
        std::unique_ptr<A> pa(new A());

        // pb 도 객체를 가리키게 할 수 있을까?
        std::unique_ptr<A> pb = pa;
    }
    ```

    만약 위 코드를 컴파일하려 했다면, 삭제된 함수를 사용하려 했다는 오류가 나오게 됩니다.
    ***
    # 삭제된 함수
    사용을 원치 않는 함수를 삭제시키는 방법은 `C++11`에 추가된 기능입니다.

    ```cpp
    #include <iostream>

    class A 
    {
    public:
        A(int a){};
        A(const A& a) = delete;
    };

    int main() 
    {
        A a(3);  // 가능
        A b(a);  // 불가능 (복사 생성자는 삭제됨)
    }
    ```

    이를 컴파일 한다면, 복사 생성자를 호출하는 부분에서 오류가 발생합니다. 왜냐하면,
    ```cpp
    A(const A& a) = delete;
    ```
    와 같이 복사 생성자를 명시적으로 삭제하였기 때문이죠. `unique_ptr` 도 마찬가지로 `unique_ptr` 의 복사 생성자가 명시적으로 삭제되었습니다. 
    그 이유는 `unique_ptr` 는 어떠한 객체를 유일하게 소유해야 하기 때문이지요. 
    만일 `unique_ptr` 를 복사 생성할 수 있게 된다면, 특정 객체를 여러 개의 `unique_ptr` 들이 소유하게 되는 문제가 발생합니다. 
    따라서, 각각의 `unique_ptr` 들이 소멸될 때 전부 객체를 delete 하려 해서 앞서 말한 `double free` 버그가 발생하게 됩니다.
    ***
    # unique_ptr 소유권 이전
    `unique_ptr` 의 소유권 이전은 가능합니다.

    ```cpp
    std::unique_ptr<A> pb = std::move(pa);
    ```

    위와 같이 `pa`를 `pb`에 강제로 이동시켜버립니다.
    이제 `pb`가 `new A`로 생성된 객체의 소유권을 갖고, `pa`는 아무것도 가리키고 있지 않게 됩니다.

    따라서 소유권을 이동 시킨 후의 기존 `unique_ptr`에 접근하지 않도록 조심해야 합니다.

    > 소유권이 이전된 `unique_ptr`을 **댕글링 포인터( Dangling Pointer ) 라고 하며,
    > 이를 재참조 시, 런타임 오류가 발생하도록 합니다. 따라서 소유권 이전은, 댕글링 포인터를
    > 절대 다시 참조하지 않겠다는 확신 하에 이동해야 합니다.

    ***
    # unique_ptr을 함수 인자로 전달하기

    */
    #pragma endregion

#pragma endregion


#pragma region 질문 리스트
/*
1장 : 
    1. C++ 에서 빌드는 어떻게 이루어지는가?
    1.1 컴파일
    1.2 링킹
    2. 런타임, 컴파일 타임?
    3. 메모리 구조
    4. 스마트 포인터
    5. 참조 전달 방식
    6. const 참조 전달 방식
    7. 예외 처리
    8. 타입 추론 auto
    9. decltype
    10. 생성자 이니셜라이저
    11. 유니폼 초기화
    12. 컴파일 에러 / 런타임 에러 / 링킹 에러 / 논리 에러 / 파스 에러

2장 :
    1. 스트링 리터럴
    2. 로 스트링 리터럴
    3. 메모리 영역(코드, 데이터, 스택, 힙)
    4. string_view

3장 :
    1. 주석 작성법

4장 :
    1. 추상화
    2. 재사용
    3. 빅-오 표기법

5장 :
    1. has-a 관계, is-a 관계
    2. 다형성과 코드 재사용
    3. 상속
    4. 믹스인 클래스
    5. 인터페이스

6장 :
    1. 응집도 / 결합도
    2. 템플릿
    3. 개방/폐쇄 원칙, 그리고 상속
    4. SOLID 원칙

7장 :
    1. 메모리 할당 / 스택과 힙
    2. 메모리 누수
    3. malloc() 과 new 그리고 realloc()
    4. 힙 영역의 배열 할당
    5. 포인터의 타입캐스팅
    6. 포인터 연산
    7. 가비지 컬렉션
    8. unique_ptr
    9. shared_ptr
    10. 레퍼런스 카운팅
    11. weak_ptr
    12. 메모리 문제
    13. 댕글링 포인터

8장 :
    1. struct와 class 그리고 접근 제한자
    2. this 포인터
    3. 객체의 라이프 사이클
    4. 생성자 / 디폴트 생성자 / 생성자 이니셜라이저 순서 주의사항 / 복제 생성자
    5. 생성자 정리
    6. 레퍼런스 전달
    7. 소멸자
    8. 대입연산자

9장 :
    1. friend
    2. 얕은 복제, 깊은 복제
    3. 복제 후 맞바꾸기 패턴
    4. Lvalue, Rvalue
    5. Rvalue Reference
    6. 이동 의미론 ( Move Semantics )
    7. 표준 라이브러리 std::swap
    8. Rule of Three, Rule of Five, Rule of Zero
    9. Static 메서드
    10. const 메서드
    11. mutable 변수
    12. 오버로딩
    13. const 기반 오버로딩
    14. 명시적으로 오버로딩 제거하기
    15. 인라인 메서드
    16. 데이터 멤버의 종류
    17. const static 멤버 변수
    18. 클래스에 열거 타입 정리
    19. 연산자 오버로딩 / 전역 연산자 오버로딩

10장 :
    1. 상속
    2. final 키워드 ( 클래스 / 메서드 )
    3. 오버라이딩 / Virtual / override 키워드
    4. 슬라이싱
    5. 정적 바인딩 / 동적 바인딩
    6. virtual 소멸자
    7. Cpp의 객체 생성과정
    8. 업캐스팅 / 다운캐스팅
    9. 순수 가상 함수
    10. 다중 상속
    11. 리스코프 치환 원칙
    12. 클래스 내에서의 using 키워드
    13. 생성자의 명시적 상속
    14. RTTI
    15. non-public 클래스 상속 
    16. 가상 베이스 클래스

*/
#pragma endregion




//-------------------------------------------------------------------------------------------------//

int main()
{
    std::cout << "Hello World!\n";
    
}

